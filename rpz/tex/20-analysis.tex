\chapter{Аналитический раздел}
\label{cha:analysis}
%
% % В начале раздела  можно напомнить его цель
%
 Есть несколько общепринятых характеристик алгоритма:\cite{vc85}
\begin{enumerate}
	\item	Количество операций с пикселями
	\item	Количество предварительных вычислений
	\item	Количество поддерживаемых динамических параметров
	\item	Деградация изображения относительно наивной реализации
\end{enumerate}
В связи с тем, что последнее время сильно выросли разрешающие способности экранов и, как следствие, выросла нагрузка на аппаратную часть, необходимо будет обратить внимание на скорость работы алгоритмов.
Под деградацией изображения понимается его отличие от того, что хотел нарисовать пользователь, получившиеся из-за особенностей работы устройства ввода и рисующего алгоритма, подробнее способ сравнения будет рассмотрен в исследовательской части.
Так как у графического планшета могут быть различные дополнительные, по сравнению с мышкой, датчики, такие как датчик давления и датчик наклона пера, параметры рисуемой линии могут меняться в зависимости от изменения их значений в процессе рисования для большей реалистичности. Возможные динамические параметры кисти:
\begin{enumerate}
	\item	Цвет
	\item	Размер
	\item	Прозрачность
	\item	Форма
\end{enumerate}

\section{Анализ существующих алгоритмов}

В качестве входных данных нам поступает некоторый набор точек, по которым мы рисуем кривую. Так что у нас есть две подзадачи: обработка набора точек и его отрисовка. Будем называть мазком результат отрисовки нашей кисти в одной точке.
%\begin{itemize}
%	\item 	
%\end{itemize}

\subsection{Базовый алгоритм}
Самым простым способом отрисовки будет рассмотрение каждых двух точек в наборе как начало и конец отрезка, которые мы соединяем проводя линию мазком который должен быть в начальной точке.\\
\begin{figure}
	[ht]
	\centering
	\includegraphics[width=\textwidth]{inc/png/naive}
	\caption{Визиты пикселей в базовой реализации}
	\label{fig:fig01}
\end{figure}\\
Обозначим длину линии соединяющей точки как $d$, а радиус круга, описывающего мазок, как $r$, тогда получаем $O(dr^2)$ визитов пикселей, $O(d)$ вычислений, деградация изображения будет заметна при достаточно большом расстоянии между точками.\\


\subsection{Наивный алгоритм отрисовки мазками}
В случае наивного алгоритма каждые две точки в наборе мы рассматриваем как начало и конец линии, с помощью алгоритма, аналогичного Брезенхему, мы выбираем из линии пиксели и каждый из них считаем центром отдельного мазка, это позволяет плавно изменять параметры между мазками. По сложности алгоритм отличается от базового незначительно $O(d((r_1+r_2)/2)^2)$ визитов пикселей, где $r_1$ это радиус мазка в начальной точке, а $r_2$ радиус мазка в конечной точке, вычислений также $O(d)$.\cite{vc85}\\
\begin{figure}
	[ht]
	\centering
	\includegraphics[width={0,35\textwidth}]{inc/png/modnice}
	\caption{Динамическое изменение толщины и прозрачности между точками}
	\label{fig:fig1}
\end{figure}\\
\subsection{Алгоритм отрисовки мазками с модификацией отступов}
В наивном алгоритме мы рисовали новый мазок на каждом следующем пикселе на пути линии, попробуем уменьшить частоту отрисовки мазков в зависимости от их размера. Слева показан результат рисования кистью в виде незаполненного круга, справа - заполненного. \\
При очень большом отступе в 200 \% радиуса мазка получаем отдельные мазки, а не линию, как видно на рисунке 1.3.
\begin{figure}
	[ht]
	\centering
	\includegraphics[width=\textwidth]{inc/png/spc200}
	\caption{Отступ 200 \% радиуса мазка}
	\label{fig:fig02}
\end{figure}\\

На рисунке 1.4 видно, что в случае относительно небольшого отступа в 25 \% радиуса мазка получаем линии, однако деградация картинки при рисовании незаполненным кругом всё ещё очень велика.
\begin{figure}
	[ht]
	\centering
	\includegraphics[width=\textwidth]{inc/png/spc25}
	\caption{Отступ 25 \% радиуса мазка}
	\label{fig:fig03}
\end{figure}\\

На рисунке 1.5 видно, что при отступе в 1 \% радиуса мазка мы получаем визуально красивые линии для обеих кистей. Такой отступ сэкономит ресурсы относительно наивной реализации для кистей с радиусом более 100 пикселей.
\begin{figure}
	[!ht]
	\centering
	\includegraphics[width=\textwidth]{inc/png/spc1}
	\caption{Отступ 1 \%  радиуса мазка}
	\label{fig:fig04}
\end{figure}

В отличие от простого алгоритма мы получаем некоторый выигрыш в скорости, но при этом происходит ухудшение качества изображения. Оптимальным вариантом является использование отступа в 25\% для непрозрачной кисти\cite{bp04}.По сложности алгоритм отличается от наивной отрисовки мазками в $min(r_1,r_2)/4$ раз по визитам пикселей, что не меняет порядок сложности в $O(d((r_1+r_2)/2)^2)$ визитов пикселей, где $r_1$ это радиус мазка в начальной точке, а $r_2$ радиус мазка в конечной точке, вычислений также $O(d)$

\subsection{Алгоритм Бидермана}
Данный алгоритм требует, чтобы кисть была выпуклым многоугольником, не поддерживает прозрачность и изменение параметров между точками. Идея заключается в том, чтобы в случае симметричной кисти представить её как кисть высотой $2r$ и шириной в один пиксель - центральный столбец кисти. Тогда в начале и конце отрезка можно нарисовать полные мазки, а между ними закрасить всё этой упрощённой кистью. Для асимметричной кисти требуется взять две кисти - горизонтальный и вертикальный разрезы. Соответственно, алгоритм прохода по линии, аналогичный Брезенхему, решает, какой из мазков использовать: при движении по горизонтали - вертикальный, при движении по вертикали - горизонтальный и при движении по диагонали - оба.\cite{vc85}

\begin{figure}
	[ht]
	\centering
	\includegraphics[width=\textwidth]{inc/png/biedermann}
	\caption{Симметричный случай Бидермана}
	\label{fig:fig05}
\end{figure}

В этом алгоритме мы получаем $O(dr)$ визитов пикселей, $O(d)$ вычислений, ухудшение качества изображения и отсутствие поддержки прозрачности.

%\subsection{Заметающий алгоритм}
%Форма обязана быть выпуклым многоугольником, а также алгоритм не поддердживает плавное изменение параметров между %точками. На краях отрисовывается по мазку, после чего создаётся матрица просчитывающая след мазка \cite{vc85}

\subsection{Алгоритм с использованием сплайнов}
В статье \cite{cgim02} рассматривается два вида сплайнов: Б-сплайны и интерполяционные сплайны. Разница заключается в том, что интерполяционный обязательно проходит через центры точек, а Б-сплайн аппроксимирует и не обязан проходить через них, однако общая идея одинаковая. Так как нам важно наиболее близкое соответствие рисунка мазку, мы будем использовать одну из разновидностей интерполяционного сплайна. На некотором расстоянии друг от друга выбираются контрольные точки, которые мы назовём узлами и в которых мы будем хранить значения различных параметров. С помощью сплайнов мы строим кривую, соединяющую точки мазков в узлах. С помощью построенной кривой получаем набор промежуточных между узлами точек, которые соединяются одним из алгоритмов соединения двух точек, линейно изменяя параметры от узла к узлу. Чем большая степень используется для полиномов в сплайне, тем больше требуется вычислений и тем сильнее он колеблется между узлами, потому оптимально использовать кубический сплайн. \cite{aspline70} Основные проблема алгоритма - сложность предварительных вычислений, которые зависят только от количества точек и возможность \textquotedblleftвыброса\textquotedblright - некрасиво построенного сплайна между точками.  Таким образом получаем  $O(NX_1)$ визитов пикселей, $O(NX_2)$ вычислений, где $N$ - количество интерполированных точек, $X_1$ - количество визитов пикселей а, $X_2$ - сложность вычислений в соединяющем их алгоритме и возможную деградацию изображения из-за \textquotedblleftвыбросов\textquotedblright относительно наивного метода. \cite{cgim02}\\ 

\begin{figure}
	[ht]
	\centering
	\includegraphics[width=\textwidth]{inc/png/spline}
	\caption{Слева видно оригинальную кривую, а справа результат её отрисовки сплайном}
	\label{fig:fig06}
\end{figure}

\section{Сравнение алгоритмов}
 $d$ - расстояние между соседними точками, $r$ - диаметр мазка, а $N$ - количество точек при интерполяции.
\begin{table}
	[ht]
	\begin{tabular}{|p{0.31\textwidth}|p{0.1\textwidth}|p{0.12\textwidth}|p{0.11\textwidth}|p{0.12\textwidth}|p{0.12\textwidth}|}
		\hline
		Алгоритм     & Базовый & Наивный & Мод. отступов  & Бидерман  & Сплайны\\
		\hline
		Операций с пикселями  & $O(dr^2)$ & $O(dr^2)$   & $O(dr^2)$    & $O(dr)$       & $O(dr^2)$         \\
		Предварит. вычислений      & $O(d)$  & $O(d)$   & $O(d)$    & $O(d)$     & $O(N)$          \\
		Поддержка всех параметров & Да   & Да   & Да    & Нет     & Да          \\
		Деградация изображения & Да & Нет  & Да  & Да     & Да          \\
		\hline
	\end{tabular}
	\caption{Сравнение алгоритмов}
	\label{tab:tabular01}
\end{table}
\section{Выводы}
В большинстве современных редакторов используется алгоритм отрисовки мазками с отступами из-за его относительно простой реализации, почти незаметного ухудшения качества изображения по сравнению с наивной реализацией при использовании небольших отступов и поддержки всех возможных параметров. Однако, он плохо подходит для рисования прозрачной кистью, поэтому представляет интерес гибрид двух алгоритмов: рисующий без отступов в случае прозрачной кисти для лучшего качества картинки и рисующий с отступами при непрозрачной кисти для лучшего быстродействия.
\par Также интересным выглядит алгоритм, использующий сплайны, поскольку из-за недостаточно высокой частоты опроса у графического планшета при быстром движении просто соединяя точки линиями мы можем увидеть что кривая состоит из нескольких отрезков, что некрасиво, а сплайн сгладит этот артефакт, однако у него велика сложность предварительных вычислений, что ставит под вопрос возможность комфортной интерактивной отрисовки.
\par Так как алгоритм Бидермана не позволяет динамически изменять параметры между точками, результат его работы будет слишком некрасив, а следовательно он не интересен, несмотря на скорость его работы.
\par Нужно определить возможно ли использование такого сложного алгоритма как отрисовка сплайнами при интерактивном вводе, требуется ли оно при рисовании с устройства ввода с относительно небольшой частотой опроса и насколько заметно отличие полученного изображения от идеала, для этого потребуется реализация  алгоритмов и сравнительные эксперименты. 

\clearpage
\section{Анализ существующих программ}
Существует достаточно много различных программ с реализациями динамических кистей, таких как относительно примитивные программы для рисования (Microsoft Paint), фоторедакторы (Adobe Photoshop) или специализированные программы для художников (Krita). Рассмотрим некоторые из них.
%Нужно бы ещё что-нибудь векторное 

\subsection{Krita}
Krita — растровый графический редактор, программное обеспечение, входящее в состав KDE как часть офисного пакета Calligra Suite. Разрабатывается преимущественно для художников и фотографов, распространяется на условиях GNU GPL.\\
Krita — Krita Foundation,2016,\\
https://krita.org/en/\\
\subsubsection{Достоинства}
\begin{enumerate}
	\item Open source.
	%\item Большой набор кистей и их параметров, импорт/экспорт, создание и измене­ние кистей и их групп. Имеются такие функции кистей как размытие, смешение цветов, стирание и т. д.
	\item Поддержка графического планшета.
	\item Программа доступна для Linux, Windows и Mac OS.
\end{enumerate}

\subsubsection{Недостатки}
\begin{enumerate}
	\item Медленная работа с кистями большого размера.
\end{enumerate}

\subsection{Adobe Photoshop}
Adobe Photoshop — многофункциональный графический редактор, разрабо­танный и распространяемый фирмой Adobe Systems. В основном работает с растро­выми изображениями, однако имеет некоторые векторные инструменты. Изначально данное ПО было разработано как редактор изображений для полиграфии, но в дан­ное время оно широко используется и в веб-дизайне.\\
Adobe Photoshop CS6 — Adobe Systems, 2016,\\
http://www.adobe.com/ru/products/photoshop.html\\

\subsubsection{Достоинства}
\begin{enumerate}
	\item Поддержка графического планшета.
	\item Тесная связь с другими продуктами Adobe Systems.
	\item Поддержка Windows, Mac OS, а также мобильных ОС Android и iOS
\end{enumerate}

\subsubsection{Недостатки}
\begin{enumerate}
	\item Высокая цена лицензии.
\end{enumerate}

\subsection{Microsoft Paint}
Microsoft Paint — многофункциональный, но в то же время довольно простой в использовании растровый графический редактор компании Microsoft, входящий в состав всех операционных систем Windows, начиная с первых версий.\\
Microsoft Paint - Microsoft Corporation, 2016,\\
https://www.microsoft.com/ru-ru/windows\\

\subsubsection{Достоинства}
\begin{enumerate}
	\item Предустановлен в Windows.
	\item Прост в пользовании.
\end{enumerate}

\subsubsection{Недостатки}
\begin{enumerate}
	\item Примитивен, не предназначен для профессионального рисования.
	\item Не поддерживает Mac OS и Linux.
\end{enumerate}

\subsection{MyPaint}
MyPaint — растровый графический редактор, программа для цифровых ху­дожников. Представляет собой минимальную функциональность графического ре­дактора, неограниченный холст и минимизированный интерфейс на GTK+.\\
MyPaint - MyPaint Contributors,2016,\\
http://mypaint.org/\\


\subsubsection{Достоинства}
\begin{enumerate}
	\item Open source.
	\item Большой набор кистей и их параметров, импорт/экспорт, создание и изменение кистей и их групп. Имеются такие функции кистей как размытие, смешение цветов, стирание и т. д.
	\item Поддержка графического планшета.
	\item Программа доступна для Linux, Windows и Mac OS.
\end{enumerate}

\subsubsection{Недостатки}
\begin{enumerate}
	\item Обладает минимальным интерфейсом и функциями исключительно для рисования, отсутствуют характерные для графических редакторов функции как выделение, масштабирование или фильтры.
\end{enumerate}

%%%Для реализации выберается алгоритм с модификацией отступов, однако ему требуется адаптация для работы с большими кистями. 
% Обратите внимание, что включается не ../dia/..., а inc/dia/...
% В Makefile есть соответствующее правило для inc/dia/*.pdf, которое
% берет исходные файлы из ../dia в этом случае.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
